var _dview;

// wraps two uint32s into double precision
function u2d(low,hi){
	if (!_dview) _dview = new DataView(new ArrayBuffer(16));
	_dview.setUint32(0,hi);
	_dview.setUint32(4,low);
	return _dview.getFloat64(0);	
}

// unwraps uints from double 
function d2u(d) {
	if (!_dview) _dview = new DataView(new ArrayBuffer(16));
	_dview.setFloat64(0,d);
	return { low: _dview.getUint32(4), hi: _dview.getUint32(0) };
}

// Cast Uint to Int
function Int(u) {
    if (u > 0x7fffffff) {
        return (((0xffffffff - u) * -1) -1);
    } else {
        return u;
    }
}

// Swap endianness of 32-bit number
function swap32(val) {
    return (((val & 0xFF) << 24)
           | ((val & 0xFF00) << 8)
           | ((val >> 8) & 0xFF00)
           | ((val >> 24) & 0xFF)) >>> 0;
}

// outputs the content of array object
function ArrayToString(arr, offs, len) {
	var str = "["; 
	len += offs-1;	
	for (var i=offs; i <= len; i++) {
	  	str += (arr[i] > 9 && arr[i] <= 0xffffffff) ? "0x" + arr[i].toString(16) : arr[i];
	  	str += (i < len) ? ", " : "]";
	}
	return str;
}

var _log0, _log;

// prints log messages
function logAdd(txt){
	if (!_log0){
		_log0 = document.getElementById("log");
		if (!_log0)
			return;
	}

	if (!_log){
		_log = document.createElement("div");
		if (_log0.hasChildNodes()) {
			_log0.insertBefore(_log, _log0.firstChild);
		} else {
			_log0.appendChild(_log);
		}
	}

	var div = document.createElement("div");
	div.innerHTML = txt;	
	_log.appendChild(div);
}

function logdbg(txt) {
	logAdd(txt);
}

function myhexdump(addr, size) {
	var msg = "";
	for (var i=0; i<size; i+=0x10) {
		msg = "";
		//msg += (sceSysmem_data_base + i).toString(16).toUpperCase() + " | ";
		for (var q=0; q<0x10; q++) {
			msg += (aspace[addr + i + q] <= 0xF) ? ("0" + aspace[addr + i + q].toString(16).toUpperCase()) : aspace[addr + i + q].toString(16).toUpperCase();
			msg += " ";
		}
		msg += ": ";
		for (var q=0; q<0x10; q++)
			msg += String.fromCharCode(aspace[addr + i + q]);
		logdbg(msg);
	}
}

// Get some storage space
function init_memory(start_addr) {
    return function(size) {
        var res = start_addr;
        start_addr += size;
        return res;
    }
}

function myprintf(addr) {
    var res = "";
    while (true) {
        var curr = String.fromCharCode(aspace[addr++]);
        if (curr == "\x00")
            break;
        res += curr;
    }
    logdbg(res);
}

function mymemset(addr, b, len) {
    for (var i = 0; i < len; i++)
        aspace[addr + i] = b;
}

function mymemcpy(addr, data, len) {
    for (var i = 0; i < len; i++)
        aspace[addr + i] = data.charCodeAt(i);
}

function stringify(string) {
	var string_p = allocate_memory(string.length + 1);
	mymemset(string_p, 0, string.length + 1); // very important: adds the null-byte terminating character
	mymemcpy(string_p, string, string.length);
	return string_p;
}

function readNullTermString(addr) {
    var i = aspace[addr];
    var str = "";
    while (i !== 00) {
        str += String.fromCharCode(i);
        addr++;
        i = aspace[addr];
    }
    return str;
}

// Get len bytes from addr
function get_bytes(addr, len) {
    var retbuf = "";
    for (var i = 0; i < len; i++) {
        hex = aspace[addr + i].toString(16);
        if (hex.length == 1)
            hex = "0" + hex;
        retbuf = retbuf + hex;
    }
    return retbuf;
}

// Get module base address using given offsets
function get_base_from_offsets(landmark, entry_off, base_off) {
    var entryaddr = landmark + entry_off;
    var entry = get_bytes(entryaddr, 4);
    entry = parseInt(entry, 16);
    entry = swap32(entry);
    var movw = get_bytes(entry, 4);
    movw = parseInt(movw, 16);
    movw = swap32(movw);
    movw = imm_movx(movw);
    var movt = get_bytes(entry + 4, 4);
    movt = parseInt(movt, 16);
    movt = swap32(movt);
    movt = imm_movx(movt);

    var ptr = ((movt << 16) | movw) >>> 0;
    var base = ptr - base_off;

    return base;
} 

// Get the immediate from a movw/t
function imm_movx(ins) {
    var imm12 = ins & 0xfff;
    var imm4 = ins & 0xf0000;
    return ((imm4 >> 4) | (imm12)) & 0xffff;
}